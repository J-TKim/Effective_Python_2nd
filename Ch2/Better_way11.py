# 슬라이싱 구문의 기본 형태는 [시작:끝]이다 끝 인덱스에 있는 원소는 포함되지 않는다
a = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
print('가운데 2개:', a[3:5])
print('마지막을 제외한 나머지:', a[1:7])

# 리스트의 맨 앞부터 슬라이싱 할 때는 시각적 잡음을 없애기 위해 0을 생략한다
assert a[:5] == a[0:5]

# 리스트의 끝까지 슬라이싱할 때는 쓸데없이 끝 인덱스를 적지 않는다
assert a[5:] == a[5:len(a)]

# 리스트의 끝부터 원솔르 찾고 싶을 때는 음수 인덱스를 사용하면 된다
print(a[:]) # ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
print(a[:5]) # ['a', 'b', 'c', 'd', 'e']
print(a[:-1]) # ['a', 'b', 'c', 'd', 'e', 'f', 'g']
print(a[-3:]) # ['f', 'g', 'h']
print(a[2:5]) # ['c', 'd', 'e']
print(a[2:-1]) # ['c', 'd', 'e', 'f', 'g']
print(a[-3:-1]) # ['f', 'g']]

# 슬라이싱할 때 리스트의 인덱스 범위를 넘어가는 시작과 끝 인덱스는 무시됨
first_twenety_items = a[:20]
last_twenty_items = a[-20:]

# 그러나 같은 인덱스에 직접 접근하면 에러가 발생한다
# a[20]
# IndexError: list index out of range

# 리스트를 슬라이싱한 결과는 완전히 새로운 리스트이므로 기존 리스트의 참조 역시 그대로 유지된다
b = a[3:]
print('이전:', b)
b[1] = 99
print('이후:', b)
print('변화 없음:', a)

# 다음 코드는 리스트에 지정한 슬라이스 길이보다 대입되는 배열의 길이가 더 짧아 리스트가 줄어든다
print('이전:', a)
a[2:7] = [99, 22, 14]
print('이후:', a)

# 다음 코드는 리스트가 늘어나는 경우이다
print('이전:', a)
a[2:3] = [47, 11]
print('이후:', a)

# 슬라이싱에서 시작과 끝 인덱스를 모두 생략하면 원래 리스트를 복사한 새 리스트를 얻는다
b = a[:]
assert b == a and b is not a

# 시작과 끝 인덱스가 없는 슬라이스에 대입하면 변수의 이름은 다르지만 같은 리스트를 참조하게 된다
b = a
print('이전 a:', a)
print('이전 b:', b)
a[:] = [101, 102, 103]
assert a is b # 여전히 같은 리스트 객체
print('이후 a:', a) # 새로운 내용이 들어있음
print('이후 b:', b) # 같은 리스트 객체이기 때문에 a와 내용이 같다